---
// Hero: full-screen video + overlay content (video position unchanged)
---

<div id="container">
	<video
		id="hero-video"
		data-video-src="https://res.cloudinary.com/dstaxkfml/video/upload/f_auto,q_auto:low/22370-vmake_h4mfr3.webm"
		autoplay
		muted
		loop
		playsinline
		preload="none"
	></video>
	<div id="hero-scrim" aria-hidden="true"></div>
	<header id="hero-content">
		<div id="hero-identity">Pankaj Sharma</div>
		<div id="hero-main">
			<p class="hero-label">Python Developer</p>
			<h1 class="hero-headline">Building fast and scalable backend systems.</h1>
			<p class="hero-description">I focus on automation, APIs, data extraction, and performance-driven development using Python.</p>
			<div class="hero-actions">
				<a href="#projects" class="btn btn-primary">View Projects</a>
				<a href="#contact" class="btn btn-secondary">Contact</a>
			</div>
		</div>
	</header>
</div>

<style is:global>
	#container {
		position: relative;
		width: 100%;
		min-height: 100vh;
		overflow: hidden;
		contain: layout paint;
	}

	#hero-video {
		position: absolute;
		top: 0;
		left: 0;
		width: 100%;
		height: 100%;
		min-width: 100%;
		min-height: 100%;
		object-fit: cover;
		object-position: center;
		display: block;
		transform: translateZ(0);
		backface-visibility: hidden;
	}

	/* Scrim: strong left so text is always readable over video; video position untouched */
	#hero-scrim {
		position: absolute;
		inset: 0;
		background: linear-gradient(105deg, rgba(0, 0, 0, 0.82) 0%, rgba(0, 0, 0, 0.5) 32%, rgba(0, 0, 0, 0.2) 55%, transparent 72%);
		pointer-events: none;
	}

	#hero-content {
		position: absolute;
		top: 0;
		left: 0;
		right: 0;
		bottom: 0;
		display: flex;
		flex-direction: column;
		justify-content: center;
		padding: clamp(1.5rem, 5vw, 3rem) clamp(1.5rem, 6vw, 4rem);
		pointer-events: none;
	}
	#hero-content .hero-actions {
		pointer-events: auto;
	}

	#hero-identity {
		position: absolute;
		top: clamp(1.25rem, 4vw, 2rem);
		left: clamp(1.5rem, 6vw, 4rem);
		font-size: 1rem;
		font-weight: 600;
		letter-spacing: 0.02em;
		color: #fff;
	}

	#hero-main {
		max-width: 26rem;
		animation: hero-main-in 0.55s ease-out both;
	}

	@keyframes hero-main-in {
		from {
			opacity: 0;
			transform: translateY(6px);
		}
		to {
			opacity: 1;
			transform: translateY(0);
		}
	}
	@media (prefers-reduced-motion: reduce) {
		#hero-main {
			animation: none;
		}
	}

	.hero-label {
		margin: 0 0 0.625rem 0;
		font-size: 0.6875rem;
		font-weight: 500;
		letter-spacing: 0.16em;
		text-transform: uppercase;
		color: rgba(255, 255, 255, 0.78);
	}

	.hero-headline {
		margin: 0 0 1rem 0;
		font-size: clamp(1.75rem, 4vw, 2.5rem);
		font-weight: 600;
		line-height: 1.15;
		letter-spacing: -0.025em;
		color: #fff;
	}

	.hero-description {
		margin: 0 0 1.625rem 0;
		font-size: 0.9375rem;
		line-height: 1.65;
		color: rgba(255, 255, 255, 0.88);
	}

	.hero-actions {
		display: flex;
		flex-wrap: wrap;
		gap: 0.75rem;
	}

	.btn {
		display: inline-flex;
		align-items: center;
		justify-content: center;
		padding: 0.6875rem 1.375rem;
		font-size: 0.8125rem;
		font-weight: 500;
		letter-spacing: 0.03em;
		text-decoration: none;
		border-radius: 0.375rem;
		cursor: pointer;
		transition: color 0.15s ease, background 0.15s ease, border-color 0.15s ease, transform 0.15s ease;
	}
	.btn:focus-visible {
		outline: 2px solid #fff;
		outline-offset: 3px;
	}

	.btn-primary {
		background: #fff;
		color: #0a0a0a;
		border: none;
	}
	.btn-primary:hover {
		transform: translateY(-1px);
		background: rgba(255, 255, 255, 0.98);
	}

	.btn-secondary {
		background: transparent;
		color: #fff;
		border: 1px solid rgba(255, 255, 255, 0.5);
	}
	.btn-secondary:hover {
		border-color: rgba(255, 255, 255, 0.75);
		background: rgba(255, 255, 255, 0.06);
		color: #fff;
	}

	/* Mobile: head space + a bit zoomed out (~80% scale) */
	@media screen and (max-width: 768px) {
		#container {
			background: rgb(251, 251, 251);
		}
		#hero-video {
			object-fit: cover;
			object-position: center center;
			width: auto;
			height: 100%;
			top: 60%;
			left: 50%;
			transform: translate(-50%, -45%) scale(0.8);
			transform-origin: center center;
		}
		#hero-scrim {
			background: linear-gradient(180deg, rgba(0, 0, 0, 0.5) 0%, rgba(0, 0, 0, 0.45) 40%, rgba(0, 0, 0, 0.78) 100%);
		}
		#hero-content {
			justify-content: flex-end;
			padding-bottom: clamp(2rem, 8vw, 3rem);
		}
		#hero-main {
			max-width: none;
		}
		.hero-headline {
			font-size: clamp(1.5rem, 6vw, 2rem);
		}
	}
</style>

<script>
	const CACHE_NAME = 'hero-video-v1';
	const video = document.getElementById('hero-video');
	const videoUrl = video?.getAttribute('data-video-src');
	if (!video || !videoUrl) throw new Error('Hero video element or URL missing');

	function setVideoSourceFromBlob(blob) {
		const blobUrl = URL.createObjectURL(blob);
		video.src = blobUrl;
		video.load();
		video.play().catch(() => {});
		// Revoke blob URL when video can play through (optional, or on unload)
		video.addEventListener('canplaythrough', () => URL.revokeObjectURL(blobUrl), { once: true });
	}

	function loadVideo() {
		// Prefer Cache API so we don't re-download on next visit
		const tryCache = async () => {
			try {
				const cache = await caches.open(CACHE_NAME);
				const cached = await cache.match(videoUrl);
				if (cached) {
					const blob = await cached.blob();
					setVideoSourceFromBlob(blob);
					return;
				}
			} catch {
				// Cache not available (e.g. private mode), fall through to fetch
			}
			const res = await fetch(videoUrl);
			const blob = await res.blob();
			try {
				const cache = await caches.open(CACHE_NAME);
				await cache.put(videoUrl, new Response(blob, { headers: res.headers }));
			} catch {
				// Ignore cache write errors
			}
			setVideoSourceFromBlob(blob);
		};
		if ('requestIdleCallback' in window) {
			window.requestIdleCallback(() => tryCache(), { timeout: 1500 });
		} else {
			setTimeout(() => tryCache(), 300);
		}
	}

	loadVideo();

	// Pause video when off-screen to reduce scroll lag and CPU/GPU usage
	const observer = new IntersectionObserver(
		(entries) => {
			const e = entries[0];
			if (!e || !video) return;
			if (e.isIntersecting) {
				video.play().catch(() => {});
			} else {
				video.pause();
			}
		},
		{ rootMargin: '20% 0px', threshold: 0 }
	);
	observer.observe(video);
</script>
